

# 什么情况下需要考虑分库分表

### 1. 单表数据量过大（最核心场景）

当单张表的数据量达到一定规模时，会导致：

- **查询变慢**：索引失效或查询扫描行数过多（例如 MySQL 单表超过 1000 万行后，查询性能明显下降）。
- **写入 / 更新卡顿**：频繁的插入 / 更新会导致表锁 / 行锁竞争加剧，事务提交变慢。
- **索引维护成本高**：索引文件过大，插入数据时索引更新耗时增加。



**经验值**：

- MySQL：单表行数建议控制在 500 万～1000 万以内（视字段多少和查询复杂度调整）。
- 其他数据库（如 PostgreSQL、SQL Server）阈值略高，但超过 1 亿行通常需要分片。

### 2. 数据库读写压力过大

- **读压力大**：当单库的 QPS（每秒查询量）过高（例如超过 1 万 QPS），数据库连接池频繁满员，查询响应延迟。
- **写压力大**：高频写入（如日志、订单系统）导致磁盘 IO 瓶颈，单库写入吞吐量不足。



分库可以将读写压力分散到多个数据库实例，避免单库过载。

### 3. 业务增长可预见，提前规避瓶颈

如果业务处于快速增长期（如用户量、订单量按月翻倍），即使当前数据量不大，也需要提前规划分库分表：

- 避免后期数据量爆炸时，紧急拆分导致的业务中断。
- 例如：社交平台的用户表、电商的订单表，这类数据通常持续增长且难以清理。

### 4. 数据热点问题突出

某些表存在「热点数据」，即部分数据被高频访问，导致：

- 热点行竞争：例如某热门商品的库存表，大量并发更新导致锁等待。
- 分区倾斜：数据分布不均（如某地区用户数据占比 80%），单表 / 单库负载过高。

分库分表可将热点数据分散到不同分片，均衡负载。

### 5. 存储容量限制

当单库数据文件过大（例如超过 100GB），会导致：

- 备份 / 恢复耗时过长（可能需要数小时）。
- 磁盘空间不足，且单服务器扩容成本高（相比多服务器分布式存储）。

分库可将数据分散到多台服务器的磁盘，突破单节点存储限制。

### 不需要分库分表的场景

- 数据量小（如几万行）且增长缓慢（如配置表、字典表）。
- 业务访问频率低（如历史归档数据，每月仅查询几次）。
- 初期快速迭代阶段，优先保证业务上线，待数据规模明确后再考虑分片。

**总结**：分库分表是「治大病」的方案，会增加系统复杂度（如跨分片查询、事务处理）。建议在数据量 / 访问量接近数据库性能阈值时，结合业务增长趋势，提前规划实施。

在 ThinkPHP 中实现分库分表，主要是为了解决数据量过大导致的性能问题。分库是将数据拆分到不同的数据库，分表是将一张大表拆分成多个小表。对于新手来说，可以从基础的手动分片开始理解，再逐步使用框架扩展或中间件。

#  php框架下分库分表

### 一、核心概念

- **分库**：按规则将数据分散到多个数据库（如按用户 ID 范围分到 db1、db2）。
- **分表**：将一张表拆分成多个子表（如 user 表拆成 user_0、user_1、...、user_n）。
- **分片策略**：常见的有「范围分片」（如 ID 1-10000 放表 0）、「哈希分片」（如 ID 取模分表）等。

### 二、ThinkPHP 中手动实现分库分表（适合新手入门）

#### 1. 配置多数据库连接

先在`config/database.php`中配置多个数据库连接（分库需要）：

```php
return [
    // 默认连接
    'default' => 'db1',
    
    // 数据库连接配置
    'connections' => [
        // 第一个库
        'db1' => [
            'type'            => 'mysql',
            'hostname'        => '127.0.0.1',
            'database'        => 'db1', // 库名
            'username'        => 'root',
            'password'        => '123456',
            'hostport'        => '3306',
        ],
        // 第二个库（分库时用）
        'db2' => [
            'type'            => 'mysql',
            'hostname'        => '127.0.0.1',
            'database'        => 'db2', // 第二个库名
            'username'        => 'root',
            'password'        => '123456',
            'hostport'        => '3306',
        ],
    ],
];
```

#### 2. 分表实现（以用户表为例）

假设用户表`user`按「ID 取模」分表（拆成`user_0`、`user_1`），步骤：

##### （1）创建模型，动态指定表名

在模型中根据业务规则（如用户 ID）计算实际表名：

```php
// app/model/User.php
namespace app\model;

use think\Model;

class User extends Model
{
    // 基础表名（不含后缀）
    protected $name = 'user';
    
    // 动态获取表名（分表核心）
    public function getTable($userId = null)
    {
        if (is_null($userId)) {
            return parent::getTable(); // 默认表名
        }
        // 按用户ID取模2，分成2张表（user_0、user_1）
        $suffix = $userId % 2;
        return $this->name . '_' . $suffix;
    }
    
    // 示例：根据ID查询用户（自动匹配分表）
    public function getUserById($userId)
    {
        // 动态切换到对应分表
        $this->table($this->getTable($userId));
        return $this->where('id', $userId)->find();
    }
    
    // 示例：新增用户（自动写入对应分表）
    public function addUser($data)
    {
        // 假设$data包含id，根据id分表
        $userId = $data['id'];
        $this->table($this->getTable($userId));
        return $this->save($data);
    }
}
```

#### 3. 分库实现（结合分表）

如果同时需要分库（如 ID<10000 放 db1，ID>=10000 放 db2），可以在模型中动态切换数据库连接：

```php
// 在User模型中增加分库逻辑
public function getDbConfig($userId)
{
    // 按ID范围分库
    if ($userId < 10000) {
        return 'db1'; // 连接db1
    } else {
        return 'db2'; // 连接db2
    }
}

// 改造查询方法，同时支持分库分表
public function getUserById($userId)
{
    // 1. 切换数据库连接
    $dbConfig = $this->getDbConfig($userId);
    $this->connect($dbConfig);
    
    // 2. 切换分表
    $this->table($this->getTable($userId));
    
    return $this->where('id', $userId)->find();
}
```

### 三、使用扩展简化分库分表（进阶）

手动分片适合简单场景，复杂场景（如动态扩容、跨表查询）建议用框架扩展，例如：

#### 1. ThinkPHP 分片扩展

- **tp5-sharding**（适用于 TP5）：通过配置文件定义分片规则，自动处理分库分表。

- 安装：`composer require lizhichao/think-sharding`

- 配置：在

  ```
  config/sharding.php
  ```

  中定义分片规则，例如：

  ```php
  return [
      'user' => [ // 表名
          'type' => 'hash', // 哈希分片
          'num' => 4, // 4张分表
          'field' => 'id', // 分片字段（按id哈希）
      ],
  ];
  ```

- 使用：模型中继承分片模型，自动按规则分表。

#### 2. 数据库中间件（适合大规模场景）

如果数据量极大，可使用中间件（如 MyCat、Sharding-JDBC），应用层（ThinkPHP）无需修改代码，中间件自动处理分库分表。

### 四、注意事项

1. **分片策略设计**：尽量选择查询频繁的字段作为分片键（如用户 ID），避免跨表 / 跨库查询。
2. **事务问题**：跨库事务难以保证，设计时尽量避免。
3. **扩容问题**：提前规划分片数量（如按 2 的 n 次方分表，方便后期扩容）。
4. **索引一致性**：所有分表的表结构和索引必须一致。

对于新手，建议先从「按 ID 取模分表」这种简单场景练手，理解分片逻辑后，再根据业务复杂度选择扩展或中间件。

分库分表是应对数据库性能瓶颈的重要手段，但并非所有场景都需要。通常在以下情况，需要考虑引入分库分表：


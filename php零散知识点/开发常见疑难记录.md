##   如何将**explode**分割后的字符修改为<font color='green'>int</font>类型

**参考资料**

| 名称     | 地址                                                         |
| -------- | ------------------------------------------------------------ |
| 网络博客 | [link](https://blog.csdn.net/haibo0668/article/details/108534887?utm_term=php%20%E5%A4%84%E7%90%86%E6%95%B0%E7%BB%84%E7%9A%84%E5%80%BC%E5%8F%98%E6%88%90int%E5%9E%8B&utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~sobaiduweb~default-0-108534887-null-null&spm=3001.4430) [link](https://www.itranslater.com/qa/details/2120199784635040768) |

**说明**

> 今天开发过程中遇到问题,返回的处理前端说要 **int**类型不然不好处理,本来我也想到了**array_map**批量处理一下
>
> 写个闭包结果**map**中无法检测到闭包函数，查阅百度发现可以闭包直接填写**全局变量例如intval** ,**骚操作只能说**

**问题代码**

```php
# 解决之前   
   /**
    * explode('*', $list->arg_string_id)); 代码分割出来字符为中文例如:["205","206"]
    */
  return self::field('arg_string_id,price')->where('service_id', $service_id)
           ->select()
            ->map(function ($list) {
                $list->arg_id = explode('*', $list->arg_string_id)); 
            });
# 解决之后-修改之后返回: [205,206]
 $list->arg_id = !empty($list->arg_string_id) ? array_map('intval', explode('*', $list->arg_string_id)) : "";
```

## 判断时间是否存在交集

### 判断当前时间是否在某个时间段内

**代码示例**

```shell
 /**
     * 获取转化后的活动价格
     * 在后台添加了活动方案的字段，在活动时间内，突出展示活动价。过了活动时间，只展示标准价（具体看活动方案页）
     */
    public static function getCurrentChangeStandardPrice($service_id)
    {
        $self = self::where('service_id', $service_id)->find();//查询当前实例
        $currentTime = time();//当前时间
        $standard_price = $self->standard_price ?? 0;//标准价格

        $serviceActivitys = ServiceActivityModel::where($service_id, $service_id)->select();
        if (empty($serviceActivitys)) return $standard_price;
        foreach ($serviceActivitys as $element) {
            $start_time = strtotime($element->start_time);
            $end_time = strtotime($element->end_time);
            # 核心代码
            if ($currentTime >= $start_time && $currentTime <= $end_time) return $element->activity_price;
            continue;
        }
        return $standard_price;
    }
```

### 更好的判断二

```php
    /**
     * 计算时间是否有交集
     * @return bool
     * @throws \exception\SystemException
     */
    public static function diffActivityStartAndEnd($service_id, $insertStartTime, $insertEndTime): bool
    {

        $insertStartTime = self::formatDate($insertStartTime);
        $insertEndTime = self::formatDate($insertEndTime);
        if ($insertStartTime > $insertEndTime) throw new SystemException("录入的开始日期不能大于结束日期");
        $serviceActivityModels = self::where(['service_id' => $service_id])->select();
        if (empty($serviceActivityModels)) return true;
        foreach ($serviceActivityModels as $element) {
            $elementStartTime = self::formatDate($element->start_time);//当前模型开始的时间
            $elementEndTime = self::formatDate($element->end_time);//当前模型结束的时间
            if ($insertStartTime >= $elementStartTime && $insertStartTime <= $elementEndTime) return false;
            if ($insertEndTime >= $elementStartTime && $insertEndTime <= $elementEndTime) return false;
        }
        return true;
    }
    /**
     * @param $dataTime //序列化时间
     * @param string $format 时间格式
     * @param false $unixTimestamp 是否需要返回unix时间戳类型
     * @return int|string
     * @throws \Exception
     */
    protected static function formatDate($dataTime, $format = 'Y-m-d H:i', $unixTimestamp = false)
    {
        //判断传入的时间类型并序列化
        $formatDateTime = is_int($dataTime) ? date($format, $dataTime) : date($format, strtotime($dataTime));
        $dateTime = new \DateTime($formatDateTime);
        $data = $dateTime->format($format);
        if ($unixTimestamp) return $dateTime->getTimestamp();
        return $data;
    }

#---------------------------------------------调用--------------------------------------------------------------
    protected function isAllowAppendTime($value, $rule, $data = [])
    {
        $service_id = $data['service_id'] ?? "";
        $start_time = $data['start_time'] ?? "";
        $end_time = $data['end_time'] ?? "";
        if (ServiceActivityModel::diffActivityStartAndEnd($service_id, $start_time, $end_time) == false) throw new SystemException("活动方案时间与旧方案存在时间交集请重新选择方案时间");
        return true;
    }
```

## [PHP获取本周所有日期或者最近七天所有日期](https://blog.csdn.net/qq_32450471/article/details/125974483)





##  构建6*7的日历数据

![image-20230214112511445](https://yaoliuyang-blog-images.oss-cn-beijing.aliyuncs.com/blogImages/image-20230214112511445.png)

**代码示例**

```php
   
        $date = !empty($data['date']) ? $data['date'] : date('Y-m');//需要查询的日期
        #--------------------------------------------------------------------------#
        $start_date = date('Y-m-01', strtotime($date));//本月的第一天
        $first_date_week = date('N', strtotime($start_date));//本月第一天是周几
        $lastMonthSurplusDateNum = $first_date_week - 1 - 1;
        $last_month_start_date = date('Y-m-01', strtotime('-1 month', strtotime($start_date))); //上个月一号
        $last_month_end_date = date('t', strtotime($last_month_start_date)); //上个月最后一天
        $last_month_end_date = date("Y-m-{$last_month_end_date}", strtotime($last_month_start_date)); //上个月最后一天
        $generate_start_date = date('Y-m-d', strtotime("-{$lastMonthSurplusDateNum}day", strtotime($last_month_end_date)));
        $generate_end_date = date('Y-m-d', strtotime('+41 days', strtotime($generate_start_date)));
        $generateDates = $this->generateDateInterval($generate_start_date, $generate_end_date); //构建一个月的所有日期
        dd($generateDates);
       

# 生成构建日期函数
public function generateDateInterval($minimum_time, $maximum_time)
    {
        $collection = [];
        //循环计算
        $minimum_time = strtotime($minimum_time);
        $maximum_time = strtotime($maximum_time);
        while ($minimum_time <= $maximum_time) {
            $collection[] += $minimum_time;
            $minimum_time = strtotime('+1 day', $minimum_time);
        }
        foreach ($collection as &$value) {
            $value = date('Y-m-d', $value);
        }
        return $collection;
    }
```

## [静态方法怎么调用非静态变量](https://mip.yht7.com/news/114824)

> 总所周知,静态方法只能调用静态变量,但是有时候我们静态方法中想要调用非静态变量怎么办呢

```php
 $pxs_reserve_with_aunts_name=ReserveWithAuntsModel::getTableName(); //关联带单阿姨表表名 用于写原生sql leftjoin中添加动态表名



#  实现效果如下: 写一个静态方法,然后实例化自己再次调用变量即可
<?php
namespace app\common\model;
use think\Model;

class ReserveWithAuntsModel extends Model
{
    protected $table = 'pxs_reserve_with_aunts';
    public static function getTableName()
    {
        return (new self())->table??"";
    }
}
```


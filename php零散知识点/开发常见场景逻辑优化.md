# 循环数据优化

**逻辑示例**

> 我有一个扩展字段  可是循环中每次调用**AreaService::getInstance()->getIdInFullNameList();** 都要执行redis查询就很慢

```php
public function appendText(cyModel $cy)
    {
        $areaList = AreaService::getInstance()->getIdInFullNameList();
        $cy->area_text = $areaList[$cy->area] ?? "";

        $cy->staff_number_history = json_decode($cy->staff_number_history, true);

        $cy_source_list = $this->getCySourceKeyValueList();
        $cy->cy_source_text = $cy_source_list[$cy->cy_source] ?? "";

        $cy_state_list = $this->getCyStateKeyValueList();
        $cy->cy_state_text = $cy_state_list[$cy->cy_state] ?? "";

        $cy_project_list = $this->getCyProjectKeyValueList();
        $cy->cy_project_text = $cy_project_list[$cy->cy_project] ?? "";
        return $cy;
    } 
```

这个问题的瓶颈点就在于 **`AreaService::getInstance()->getIdInFullNameList()` 每次循环都重新查询 redis**。
 解决思路就是：**把这个结果缓存到内存里（方法级 / 类级静态变量 / 外部提前获取）**，避免在循环中反复调用。

可以改造几种方式：

## 方法一：在循环外部提前获取

```php
$areaList = AreaService::getInstance()->getIdInFullNameList();

foreach ($cyList as $cy) {
    $this->appendText($cy, $areaList);
}
```

然后修改 `appendText`：

```php
public function appendText(cyModel $cy, array $areaList)
{
    $cy->area_text = $areaList[$cy->area] ?? "";

    $cy->staff_number_history = json_decode($cy->staff_number_history, true);

    $cy_source_list = $this->getCySourceKeyValueList();
    $cy->cy_source_text = $cy_source_list[$cy->cy_source] ?? "";

    $cy_state_list = $this->getCyStateKeyValueList();
    $cy->cy_state_text = $cy_state_list[$cy->cy_state] ?? "";

    $cy_project_list = $this->getCyProjectKeyValueList();
    $cy->cy_project_text = $cy_project_list[$cy->cy_project] ?? "";

    return $cy;
}
```

## 方法二：静态缓存（类内存缓存）

如果你不能改调用方式，可以在 `appendText` 内部用 **静态变量缓存**：

> 这样第一次调用时会去 Redis，后面都是内存里直接拿，循环中不会再触发 redis 查询。

```php
public function appendText(cyModel $cy)
{
    static $areaList = null;
    if ($areaList === null) {
        $areaList = AreaService::getInstance()->getIdInFullNameList();
    }

    $cy->area_text = $areaList[$cy->area] ?? "";
    $cy->staff_number_history = json_decode($cy->staff_number_history, true);

    static $cy_source_list = null;
    if ($cy_source_list === null) {
        $cy_source_list = $this->getCySourceKeyValueList();
    }
    $cy->cy_source_text = $cy_source_list[$cy->cy_source] ?? "";

    static $cy_state_list = null;
    if ($cy_state_list === null) {
        $cy_state_list = $this->getCyStateKeyValueList();
    }
    $cy->cy_state_text = $cy_state_list[$cy->cy_state] ?? "";

    static $cy_project_list = null;
    if ($cy_project_list === null) {
        $cy_project_list = $this->getCyProjectKeyValueList();
    }
    $cy->cy_project_text = $cy_project_list[$cy->cy_project] ?? "";

    return $cy;
}
```

## 方法三：依赖注入

更规范一点的做法，是在调用 service 的时候，就把 areaList、cy_source_list 等依赖传进去，这样 `appendText` 就是纯粹的数据加工函数。



## 静态变量在函数作用域内 初始化执行代码测试

在 PHP 里，**静态变量在函数作用域内只会初始化一次**，后续再调用这个函数时，值会一直保留在内存里，不会重新赋值。

比如下面这个例子：

```php
function test() {
    static $data = null;
    if ($data === null) {
        echo "执行查询...\n";
        $data = ['a' => 1, 'b' => 2]; // 模拟redis查询
    }
    return $data;
}

for ($i = 0; $i < 3; $i++) {
    $res = test();
    print_r($res);
}
```

输出结果：

```csharp
执行查询...
Array
(
    [a] => 1
    [b] => 2
)
Array
(
    [a] => 1
    [b] => 2
)
Array
(
    [a] => 1
    [b] => 2
)
```

可以看到：

- 第一次调用时 `$data === null`，于是执行了「查询」逻辑（比如 Redis）。
- 后面两次调用时 `$data !== null`，就直接返回已有的数据，不会再走 Redis。

------

所以放到你的代码里：

- **第一次调用 `appendText()`** → Redis 查询一次，赋值给静态变量。
- **后续循环调用 `appendText()`** → 直接用静态变量里的数据，不会再去 Redis。

这样就能保证循环里高效运行了。

## 性能解说

从 **性能角度** 来看，方法一和方法二在循环过程中基本 **没有差别**，原因是：

- **方法一**：在循环外先查一次 Redis，后续循环直接用传进来的数组。
- **方法二**：第一次调用函数时查一次 Redis，赋值给静态变量，后续循环直接用静态变量。

两者都只会触发 **一次 Redis 查询**，后续循环都是走内存。

------

### 细微差异：

1. **方法一**
   - 优点：逻辑清晰，谁依赖数据就明确传进去，函数是纯函数，方便测试。
   - 缺点：调用地方需要改代码（要先准备好 `$areaList`、`$cy_source_list` 等再传）。
2. **方法二**
   - 优点：调用方不用改，改造最小，旧代码直接生效。
   - 缺点：函数对外部依赖“隐藏”了，表面上看起来每次都查，但其实只查一次，不如方法一那么直观。
3. **执行速率**
   - 两者在 PHP 层面的性能差异几乎可以忽略（方法二每次多一次 `if ($var === null)` 判断，成本极低，纳秒级）。
   - 真正耗时的 Redis 查询，两种方法都是 **只执行一次**。

------

👉 总结：

- **性能：几乎一样**。
- **可维护性：方法一更清晰，方法二改造成本低**。

如果你的项目要长期维护、多人协作，推荐方法一；如果你现在就是要快速优化性能，不想动调用逻辑，直接上方法二。

#  简化逻辑判断

**简化前**

> 先看一下简化前的逻辑 
>
> if里面 又判断了if 读起来很麻烦

```php
            ###########################################################
            $is_transfer = false;
            //如果负责人离职&&未付清情况下(可以转交给其他人员)
            if (
                !empty($headModel)
                &&
                $headModel->staff_work_status == AssetMoreEnum::retuenValueFromType('4', 'work_status') //第一层 只判断离职
            ) {
                //没有签合同或者未付清 都属于 未付清
                if (empty($cySigned) || (!empty($cySigned) && $cySigned->is_full_money == CySigend::IS_FULL_MONEY__1)) { //第二层 判断未付清
                   $is_transfer = true;
                }
            }
            ###########################################################

            //如果合同不为空、收款金额大于0、&& (!离职未付清)
            if (!empty($cySigned) && $cySigned->total_received_money > 0 && $is_transfer == false) throw new PxsApiException('已签合同并收款不可再转交给其他负责人!');
```



**简化后**

> 使用更具描述性的变量名
>
> 将复杂的条件判断分解为独立的小判断
> 清晰地表达了业务逻辑关系
> 保留了原有的所有业务规则

```php
            // 简化版逻辑
            $canTransfer = false;
            // 检查负责人是否已离职
            $isHeadResigned = !empty($headModel) 
                && 
                $headModel->getOrigin('staff_work_status') == AssetMoreEnum::retuenValueFromType('4', 'work_status');
            // 检查是否未付清（没有合同或合同未付清）
            $isUnpaid = empty($cySigned) || (!empty($cySigned) && $cySigned->is_full_money == CySigend::IS_FULL_MONEY__1);
            // 如果负责人已离职且未付清，则允许转交
            if ($isHeadResigned && $isUnpaid) $canTransfer = true;//true允许转交

            // 如果已签合同并已收款，且不符合特殊转交条件，则禁止转交
            $has_total_received_money = !empty($cySigned) && $cySigned->total_received_money > 0;//已签合同并已收款
            if ($has_total_received_money && $canTransfer == false) { //有收款的 && 不符合特殊转交条件
                throw new PxsApiException('已签合同并收款不可再转交给其他负责人!');
            }
```

## 实际示例场景

> 这些优化方案的共同特点：
>
> 1. 将复杂条件拆分为独立的布尔变量，每个变量只负责一个判断
> 2. 使用清晰的变量名表达业务含义（如`$isHeadResigned`、`$isUnpaid`）
> 3. 减少嵌套层级，使逻辑流程更线性
> 4. 分离 "条件判断" 和 "业务操作"，使代码结构更清晰
> 5. 重要的业务规则可以提取为配置数组（如状态流转规则）
>
> 这种方式特别适合维护复杂的业务逻辑，当需求变更时，只需要修改对应的条件变量或规则配置即可。

###  用户权限校验逻辑优化

**优化前（嵌套复杂）：**

```php
if ($user) {
    if ($user->role == 'admin') {
        if ($user->status == 1) {
            // 管理员且状态正常，允许操作
            $allow = true;
        } else {
            $error = "管理员账号已禁用";
        }
    } else if ($user->role == 'editor') {
        if ($user->status == 1 && $user->hasPermission('edit')) {
            $allow = true;
        } else {
            $error = "编辑权限不足或账号异常";
        }
    } else {
        $error = "无权限访问";
    }
} else {
    $error = "用户未登录";
}
```

**优化后（拆分逻辑）：**

```php
// 基础状态判断
$isLoggedIn = !empty($user);
$isActive = $isLoggedIn && $user->status == 1;
$isAdmin = $isLoggedIn && $user->role == 'admin';
$isEditor = $isLoggedIn && $user->role == 'editor';
$editorHasPermission = $isEditor && $user->hasPermission('edit');

// 权限判定
if (!$isLoggedIn) {
    $error = "用户未登录";
} elseif ($isAdmin && $isActive) {
    $allow = true;
} elseif ($isEditor && $isActive && $editorHasPermission) {
    $allow = true;
} elseif (!$isActive) {
    $error = "账号已禁用";
} elseif ($isEditor && !$editorHasPermission) {
    $error = "编辑权限不足";
} else {
    $error = "无权限访问";
}
```

### 订单状态流转逻辑优化

**优化前（条件判断冗长）：**

```php
if ($order && $order->status != 'cancelled') {
    if ($action == 'pay' && $order->status == 'pending') {
        $order->status = 'paid';
        $order->paid_at = date('Y-m-d H:i:s');
    } elseif ($action == 'ship' && $order->status == 'paid') {
        $order->status = 'shipped';
        $order->shipped_at = date('Y-m-d H:i:s');
    } elseif ($action == 'receive' && $order->status == 'shipped') {
        $order->status = 'completed';
        $order->completed_at = date('Y-m-d H:i:s');
    } else {
        throw new Exception("当前订单状态不允许执行此操作");
    }
} else {
    throw new Exception("订单不存在或已取消");
}
```

**优化后（状态和动作分离）：**

```php
// 前置条件判断
$orderExists = !empty($order);
$orderNotCancelled = $orderExists && $order->status != 'cancelled';
$validStatusTransitions = [
    'pay' => ['from' => 'pending', 'to' => 'paid', 'field' => 'paid_at'],
    'ship' => ['from' => 'paid', 'to' => 'shipped', 'field' => 'shipped_at'],
    'receive' => ['from' => 'shipped', 'to' => 'completed', 'field' => 'completed_at'],
];

// 验证基础条件
if (!$orderExists) throw new Exception("订单不存在");
if (!$orderNotCancelled) throw new Exception("订单已取消");
if (!isset($validStatusTransitions[$action])) throw new Exception("不支持的操作");

// 验证状态流转合法性
$transition = $validStatusTransitions[$action];
if ($order->status != $transition['from']) {
    throw new Exception("当前订单状态不允许执行此操作");
}

// 执行状态更新
$order->status = $transition['to'];
$order->{$transition['field']} = date('Y-m-d H:i:s');
```

### 数据过滤条件优化

**优化前（查询条件嵌套）：**

```php
$query = DB::table('products');

if (!empty($category)) {
    $query->where('category_id', $category);
    if (!empty($minPrice)) {
        $query->where('price', '>=', $minPrice);
        if (!empty($maxPrice)) {
            $query->where('price', '<=', $maxPrice);
        }
    }
}

if (!empty($keyword)) {
    $query->where(function($q) use ($keyword) {
        $q->where('name', 'like', "%$keyword%")
          ->orWhere('description', 'like', "%$keyword%");
    });
}

$products = $query->get();
```

**优化后（条件分离）：**

```php
// 初始化查询
$query = DB::table('products');

// 提取条件变量
$hasCategory = !empty($category);
$hasPriceRange = $hasCategory && !empty($minPrice);
$hasMaxPrice = $hasPriceRange && !empty($maxPrice);
$hasKeyword = !empty($keyword);

// 应用分类条件
if ($hasCategory) {
    $query->where('category_id', $category);
    
    // 应用价格条件
    if ($hasPriceRange) {
        $query->where('price', '>=', $minPrice);
        if ($hasMaxPrice) {
            $query->where('price', '<=', $maxPrice);
        }
    }
}

// 应用关键词搜索
if ($hasKeyword) {
    $query->where(function($q) use ($keyword) {
        $q->where('name', 'like', "%$keyword%")
          ->orWhere('description', 'like', "%$keyword%");
    });
}

$products = $query->get();
```


# 循环数据优化

**逻辑示例**

> 我有一个扩展字段  可是循环中每次调用**AreaService::getInstance()->getIdInFullNameList();** 都要执行redis查询就很慢

```php
public function appendText(cyModel $cy)
    {
        $areaList = AreaService::getInstance()->getIdInFullNameList();
        $cy->area_text = $areaList[$cy->area] ?? "";

        $cy->staff_number_history = json_decode($cy->staff_number_history, true);

        $cy_source_list = $this->getCySourceKeyValueList();
        $cy->cy_source_text = $cy_source_list[$cy->cy_source] ?? "";

        $cy_state_list = $this->getCyStateKeyValueList();
        $cy->cy_state_text = $cy_state_list[$cy->cy_state] ?? "";

        $cy_project_list = $this->getCyProjectKeyValueList();
        $cy->cy_project_text = $cy_project_list[$cy->cy_project] ?? "";
        return $cy;
    } 
```

这个问题的瓶颈点就在于 **`AreaService::getInstance()->getIdInFullNameList()` 每次循环都重新查询 redis**。
 解决思路就是：**把这个结果缓存到内存里（方法级 / 类级静态变量 / 外部提前获取）**，避免在循环中反复调用。

可以改造几种方式：

## 方法一：在循环外部提前获取

```php
$areaList = AreaService::getInstance()->getIdInFullNameList();

foreach ($cyList as $cy) {
    $this->appendText($cy, $areaList);
}
```

然后修改 `appendText`：

```php
public function appendText(cyModel $cy, array $areaList)
{
    $cy->area_text = $areaList[$cy->area] ?? "";

    $cy->staff_number_history = json_decode($cy->staff_number_history, true);

    $cy_source_list = $this->getCySourceKeyValueList();
    $cy->cy_source_text = $cy_source_list[$cy->cy_source] ?? "";

    $cy_state_list = $this->getCyStateKeyValueList();
    $cy->cy_state_text = $cy_state_list[$cy->cy_state] ?? "";

    $cy_project_list = $this->getCyProjectKeyValueList();
    $cy->cy_project_text = $cy_project_list[$cy->cy_project] ?? "";

    return $cy;
}
```

## 方法二：静态缓存（类内存缓存）

如果你不能改调用方式，可以在 `appendText` 内部用 **静态变量缓存**：

> 这样第一次调用时会去 Redis，后面都是内存里直接拿，循环中不会再触发 redis 查询。

```php
public function appendText(cyModel $cy)
{
    static $areaList = null;
    if ($areaList === null) {
        $areaList = AreaService::getInstance()->getIdInFullNameList();
    }

    $cy->area_text = $areaList[$cy->area] ?? "";
    $cy->staff_number_history = json_decode($cy->staff_number_history, true);

    static $cy_source_list = null;
    if ($cy_source_list === null) {
        $cy_source_list = $this->getCySourceKeyValueList();
    }
    $cy->cy_source_text = $cy_source_list[$cy->cy_source] ?? "";

    static $cy_state_list = null;
    if ($cy_state_list === null) {
        $cy_state_list = $this->getCyStateKeyValueList();
    }
    $cy->cy_state_text = $cy_state_list[$cy->cy_state] ?? "";

    static $cy_project_list = null;
    if ($cy_project_list === null) {
        $cy_project_list = $this->getCyProjectKeyValueList();
    }
    $cy->cy_project_text = $cy_project_list[$cy->cy_project] ?? "";

    return $cy;
}
```

## 方法三：依赖注入

更规范一点的做法，是在调用 service 的时候，就把 areaList、cy_source_list 等依赖传进去，这样 `appendText` 就是纯粹的数据加工函数。



## 静态变量在函数作用域内 初始化执行代码测试

在 PHP 里，**静态变量在函数作用域内只会初始化一次**，后续再调用这个函数时，值会一直保留在内存里，不会重新赋值。

比如下面这个例子：

```php
function test() {
    static $data = null;
    if ($data === null) {
        echo "执行查询...\n";
        $data = ['a' => 1, 'b' => 2]; // 模拟redis查询
    }
    return $data;
}

for ($i = 0; $i < 3; $i++) {
    $res = test();
    print_r($res);
}
```

输出结果：

```csharp
执行查询...
Array
(
    [a] => 1
    [b] => 2
)
Array
(
    [a] => 1
    [b] => 2
)
Array
(
    [a] => 1
    [b] => 2
)
```

可以看到：

- 第一次调用时 `$data === null`，于是执行了「查询」逻辑（比如 Redis）。
- 后面两次调用时 `$data !== null`，就直接返回已有的数据，不会再走 Redis。

------

所以放到你的代码里：

- **第一次调用 `appendText()`** → Redis 查询一次，赋值给静态变量。
- **后续循环调用 `appendText()`** → 直接用静态变量里的数据，不会再去 Redis。

这样就能保证循环里高效运行了。

## 性能解说

从 **性能角度** 来看，方法一和方法二在循环过程中基本 **没有差别**，原因是：

- **方法一**：在循环外先查一次 Redis，后续循环直接用传进来的数组。
- **方法二**：第一次调用函数时查一次 Redis，赋值给静态变量，后续循环直接用静态变量。

两者都只会触发 **一次 Redis 查询**，后续循环都是走内存。

------

### 细微差异：

1. **方法一**
   - 优点：逻辑清晰，谁依赖数据就明确传进去，函数是纯函数，方便测试。
   - 缺点：调用地方需要改代码（要先准备好 `$areaList`、`$cy_source_list` 等再传）。
2. **方法二**
   - 优点：调用方不用改，改造最小，旧代码直接生效。
   - 缺点：函数对外部依赖“隐藏”了，表面上看起来每次都查，但其实只查一次，不如方法一那么直观。
3. **执行速率**
   - 两者在 PHP 层面的性能差异几乎可以忽略（方法二每次多一次 `if ($var === null)` 判断，成本极低，纳秒级）。
   - 真正耗时的 Redis 查询，两种方法都是 **只执行一次**。

------

👉 总结：

- **性能：几乎一样**。
- **可维护性：方法一更清晰，方法二改造成本低**。

如果你的项目要长期维护、多人协作，推荐方法一；如果你现在就是要快速优化性能，不想动调用逻辑，直接上方法二。

#  简化逻辑判断

**简化前**

> 先看一下简化前的逻辑 
>
> if里面 又判断了if 读起来很麻烦

```php
            ###########################################################
            $is_transfer = false;
            //如果负责人离职&&未付清情况下(可以转交给其他人员)
            if (
                !empty($headModel)
                &&
                $headModel->staff_work_status == AssetMoreEnum::retuenValueFromType('4', 'work_status') //第一层 只判断离职
            ) {
                //没有签合同或者未付清 都属于 未付清
                if (empty($cySigned) || (!empty($cySigned) && $cySigned->is_full_money == CySigend::IS_FULL_MONEY__1)) { //第二层 判断未付清
                   $is_transfer = true;
                }
            }
            ###########################################################

            //如果合同不为空、收款金额大于0、&& (!离职未付清)
            if (!empty($cySigned) && $cySigned->total_received_money > 0 && $is_transfer == false) throw new PxsApiException('已签合同并收款不可再转交给其他负责人!');
```



**简化后**

> 使用更具描述性的变量名
>
> 将复杂的条件判断分解为独立的小判断
> 清晰地表达了业务逻辑关系
> 保留了原有的所有业务规则

```php
            // 简化版逻辑
            $canTransfer = false;
            // 检查负责人是否已离职
            $isHeadResigned = !empty($headModel) 
                && 
                $headModel->getOrigin('staff_work_status') == AssetMoreEnum::retuenValueFromType('4', 'work_status');
            // 检查是否未付清（没有合同或合同未付清）
            $isUnpaid = empty($cySigned) || (!empty($cySigned) && $cySigned->is_full_money == CySigend::IS_FULL_MONEY__1);
            // 如果负责人已离职且未付清，则允许转交
            if ($isHeadResigned && $isUnpaid) $canTransfer = true;//true允许转交

            // 如果已签合同并已收款，且不符合特殊转交条件，则禁止转交
            $has_total_received_money = !empty($cySigned) && $cySigned->total_received_money > 0;//已签合同并已收款
            if ($has_total_received_money && $canTransfer == false) { //有收款的 && 不符合特殊转交条件
                throw new PxsApiException('已签合同并收款不可再转交给其他负责人!');
            }
```

## 实际示例场景

> 这些优化方案的共同特点：
>
> 1. 将复杂条件拆分为独立的布尔变量，每个变量只负责一个判断
> 2. 使用清晰的变量名表达业务含义（如`$isHeadResigned`、`$isUnpaid`）
> 3. 减少嵌套层级，使逻辑流程更线性
> 4. 分离 "条件判断" 和 "业务操作"，使代码结构更清晰
> 5. 重要的业务规则可以提取为配置数组（如状态流转规则）
>
> 这种方式特别适合维护复杂的业务逻辑，当需求变更时，只需要修改对应的条件变量或规则配置即可。

###  用户权限校验逻辑优化

**优化前（嵌套复杂）：**

```php
if ($user) {
    if ($user->role == 'admin') {
        if ($user->status == 1) {
            // 管理员且状态正常，允许操作
            $allow = true;
        } else {
            $error = "管理员账号已禁用";
        }
    } else if ($user->role == 'editor') {
        if ($user->status == 1 && $user->hasPermission('edit')) {
            $allow = true;
        } else {
            $error = "编辑权限不足或账号异常";
        }
    } else {
        $error = "无权限访问";
    }
} else {
    $error = "用户未登录";
}
```

**优化后（拆分逻辑）：**

```php
// 基础状态判断
$isLoggedIn = !empty($user);
$isActive = $isLoggedIn && $user->status == 1;
$isAdmin = $isLoggedIn && $user->role == 'admin';
$isEditor = $isLoggedIn && $user->role == 'editor';
$editorHasPermission = $isEditor && $user->hasPermission('edit');

// 权限判定
if (!$isLoggedIn) {
    $error = "用户未登录";
} elseif ($isAdmin && $isActive) {
    $allow = true;
} elseif ($isEditor && $isActive && $editorHasPermission) {
    $allow = true;
} elseif (!$isActive) {
    $error = "账号已禁用";
} elseif ($isEditor && !$editorHasPermission) {
    $error = "编辑权限不足";
} else {
    $error = "无权限访问";
}
```

### 订单状态流转逻辑优化

**优化前（条件判断冗长）：**

```php
if ($order && $order->status != 'cancelled') {
    if ($action == 'pay' && $order->status == 'pending') {
        $order->status = 'paid';
        $order->paid_at = date('Y-m-d H:i:s');
    } elseif ($action == 'ship' && $order->status == 'paid') {
        $order->status = 'shipped';
        $order->shipped_at = date('Y-m-d H:i:s');
    } elseif ($action == 'receive' && $order->status == 'shipped') {
        $order->status = 'completed';
        $order->completed_at = date('Y-m-d H:i:s');
    } else {
        throw new Exception("当前订单状态不允许执行此操作");
    }
} else {
    throw new Exception("订单不存在或已取消");
}
```

**优化后（状态和动作分离）：**

```php
// 前置条件判断
$orderExists = !empty($order);
$orderNotCancelled = $orderExists && $order->status != 'cancelled';
$validStatusTransitions = [
    'pay' => ['from' => 'pending', 'to' => 'paid', 'field' => 'paid_at'],
    'ship' => ['from' => 'paid', 'to' => 'shipped', 'field' => 'shipped_at'],
    'receive' => ['from' => 'shipped', 'to' => 'completed', 'field' => 'completed_at'],
];

// 验证基础条件
if (!$orderExists) throw new Exception("订单不存在");
if (!$orderNotCancelled) throw new Exception("订单已取消");
if (!isset($validStatusTransitions[$action])) throw new Exception("不支持的操作");

// 验证状态流转合法性
$transition = $validStatusTransitions[$action];
if ($order->status != $transition['from']) {
    throw new Exception("当前订单状态不允许执行此操作");
}

// 执行状态更新
$order->status = $transition['to'];
$order->{$transition['field']} = date('Y-m-d H:i:s');
```

### 数据过滤条件优化

**优化前（查询条件嵌套）：**

```php
$query = DB::table('products');

if (!empty($category)) {
    $query->where('category_id', $category);
    if (!empty($minPrice)) {
        $query->where('price', '>=', $minPrice);
        if (!empty($maxPrice)) {
            $query->where('price', '<=', $maxPrice);
        }
    }
}

if (!empty($keyword)) {
    $query->where(function($q) use ($keyword) {
        $q->where('name', 'like', "%$keyword%")
          ->orWhere('description', 'like', "%$keyword%");
    });
}

$products = $query->get();
```

**优化后（条件分离）：**

```php
// 初始化查询
$query = DB::table('products');

// 提取条件变量
$hasCategory = !empty($category);
$hasPriceRange = $hasCategory && !empty($minPrice);
$hasMaxPrice = $hasPriceRange && !empty($maxPrice);
$hasKeyword = !empty($keyword);

// 应用分类条件
if ($hasCategory) {
    $query->where('category_id', $category);
    
    // 应用价格条件
    if ($hasPriceRange) {
        $query->where('price', '>=', $minPrice);
        if ($hasMaxPrice) {
            $query->where('price', '<=', $maxPrice);
        }
    }
}

// 应用关键词搜索
if ($hasKeyword) {
    $query->where(function($q) use ($keyword) {
        $q->where('name', 'like', "%$keyword%")
          ->orWhere('description', 'like', "%$keyword%");
    });
}

$products = $query->get();
```

### 一、**逻辑简化与清晰化**

1. **消除嵌套条件（减少 if-else 层级）**嵌套过深的条件判断会导致代码 "横向蔓延"，难以理解。**优化前**：

   ```php
   if ($user) {
       if ($user->isVip()) {
           if ($order->total >= 1000) {
               $discount = 0.8;
           } else {
               $discount = 0.9;
           }
       } else {
           $discount = 1.0;
       }
   } else {
       throw new Exception("未登录");
   }
   ```

   

   **优化后**（提前 return + 扁平化）：

   ```php
   if (!$user) throw new Exception("未登录");
   if (!$user->isVip()) return 1.0;
   return $order->total >= 1000 ? 0.8 : 0.9;
   ```

   

2. **用 "卫语句" 替代复杂条件**对于特殊情况，提前返回或抛出异常，避免主逻辑被嵌套。**优化前**：

   ```php
   function calculatePrice($goods, $user) {
       if ($goods && $user && $user->status == 1) {
           // 复杂的价格计算逻辑...
           return $price;
       } else {
           return 0;
       }
   }
   ```

   

   **优化后**：

   ```php
   function calculatePrice($goods, $user) {
       if (!$goods) return 0;       // 卫语句：商品不存在
       if (!$user) return 0;        // 卫语句：用户不存在
       if ($user->status != 1) return 0;  // 卫语句：用户状态异常
       
       // 主逻辑（无需嵌套）
       // 复杂的价格计算逻辑...
       return $price;
   }
   ```

   

### 二、**变量与表达式优化**

1. **提取重复表达式为变量**重复出现的表达式会导致修改时需要多处同步，且降低可读性。**优化前**：

   ```php
   if ($order->create_time > strtotime('-30 days') && $order->status == 1 && $user->level >= 3) {
       // 逻辑1
   }
   if ($order->create_time > strtotime('-30 days') && $order->status == 1 && $user->points > 1000) {
       // 逻辑2
   }
   ```

   

   **优化后**：

   ```php
   $isRecentValidOrder = $order->create_time > strtotime('-30 days') && $order->status == 1;
   if ($isRecentValidOrder && $user->level >= 3) { /* 逻辑1 */ }
   if ($isRecentValidOrder && $user->points > 1000) { /* 逻辑2 */ }
   ```

   

2. **用常量 / 枚举替代魔法值**直接使用数字、字符串等 "魔法值" 会导致代码难以理解，修改时易出错。**优化前**：

   ```php
   if ($order->status == 2) {
       // 处理已发货订单
   }
   ```

   

   **优化后**：

   ```php
   // 定义枚举或常量
   class OrderStatus {
       const PENDING = 1;
       const SHIPPED = 2;
       const COMPLETED = 3;
   }
   
   if ($order->status == OrderStatus::SHIPPED) {
       // 处理已发货订单
   }
   ```

   

### 三、**函数与方法优化**

1. **拆分超大函数（单一职责原则）**一个函数只做一件事，避免几百行的 "万能函数"。**优化前**：

   ```php
   function handleOrder($order) {
       // 1. 验证订单合法性（50行）
       // 2. 计算价格（30行）
       // 3. 扣减库存（20行）
       // 4. 生成物流单（40行）
   }
   ```

   **优化后**：

   ```php
   function handleOrder($order) {
       $this->validateOrder($order);       // 验证
       $price = $this->calculatePrice($order);  // 计算价格
       $this->deductStock($order);         // 扣减库存
       $this->createLogistics($order);     // 生成物流单
   }
   ```

   

2. **减少函数参数（控制参数数量）**过多的参数会导致调用时容易传错顺序，可封装为对象或数组。**优化前**：

   ```php
   function createUser($name, $age, $email, $phone, $address, $role) {
       // ...
   }
   ```

   

   **优化后**：

   ```php
   class UserData {
       public $name;
       public $age;
       public $email;
       public $phone;
       public $address;
       public $role;
   }
   
   function createUser(UserData $data) {
       // 使用 $data->name 等
   }
   ```

   

### 四、**循环与迭代优化**

1. **减少循环内的计算**循环内的重复计算会浪费性能，尤其是大数据量时。**优化前**：

   ```php
   foreach ($products as $product) {
       if ($product->price > $maxPrice && $product->category == Category::ELECTRONICS) {
           // ...
       }
   }
   ```

   

   **优化后**：

   ```php
   $targetCategory = Category::ELECTRONICS;  // 循环外计算一次
   foreach ($products as $product) {
       if ($product->price > $maxPrice && $product->category == $targetCategory) {
           // ...
       }
   }
   ```

   

2. **提前终止循环**找到目标后立即 break，避免无效迭代。**优化前**：

   ```php
   $hasStock = false;
   foreach ($products as $product) {
       if ($product->id == $targetId && $product->stock > 0) {
           $hasStock = true;
       }
   }
   ```

   **优化后**：

   ```php
   $hasStock = false;
   foreach ($products as $product) {
       if ($product->id == $targetId) {
           $hasStock = $product->stock > 0;
           break;  // 找到目标后立即终止
       }
   }
   ```

   

### 五、**错误处理优化**

1. 用异常替代错误码

   

   错误码需要每层函数手动传递，异常可直接抛到上层处理。

   优化前:

   ```php
   function createOrder() {
       if (!$user) return -1;  // 错误码：用户不存在
       if (!$product) return -2; // 错误码：商品不存在
       // ...
   }
   
   // 调用时需要判断每个错误码
   $result = createOrder();
   if ($result == -1) { /* 处理用户不存在 */ }
   else if ($result == -2) { /* 处理商品不存在 */ }
   ```

   

   优化后

   ```php
   function createOrder() {
       if (!$user) throw new UserNotFoundException();
       if (!$product) throw new ProductNotFoundException();
       // ...
   }
   
   // 调用时集中处理异常
   try {
       createOrder();
   } catch (UserNotFoundException $e) {
       /* 处理用户不存在 */
   } catch (ProductNotFoundException $e) {
       /* 处理商品不存在 */
   }
   ```

   

### 六、**代码复用优化**

1. **提取重复逻辑为公共方法**多处出现的相同逻辑，应封装为公共函数或工具类。**优化前**：

   ```php
   // 页面A的价格格式化
   $priceA = number_format($rawPriceA, 2, '.', ',');
   // 页面B的价格格式化
   $priceB = number_format($rawPriceB, 2, '.', ',');
   ```

   

   **优化后**：

   ```php
   function formatPrice($price) {
       return number_format($price, 2, '.', ',');
   }
   
   $priceA = formatPrice($rawPriceA);
   $priceB = formatPrice($rawPriceB);
   ```

   

2. **使用设计模式简化复杂逻辑**例如用 "策略模式" 处理多变的算法，用 "工厂模式" 处理对象创建逻辑等。**示例（策略模式优化支付逻辑）**：

   ```php
   // 策略接口
   interface PaymentStrategy {
       function pay($amount);
   }
   
   // 具体实现（支付宝、微信）
   class AlipayStrategy implements PaymentStrategy {
       function pay($amount) { /* 支付宝支付逻辑 */ }
   }
   class WechatStrategy implements PaymentStrategy {
       function pay($amount) { /* 微信支付逻辑 */ }
   }
   
   // 使用时动态选择策略
   $payment = new PaymentContext(new AlipayStrategy());
   $payment->executePay(100);
   ```
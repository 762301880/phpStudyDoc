#  优化文档

##  [php代码简洁之道](https://learnku.com/docs/clean-code-php/introduce/12659)

## [Laravel 编码技巧](https://learnku.com/docs/laravel-tips/8.x)

# 循环数据优化

**逻辑示例**

> 我有一个扩展字段  可是循环中每次调用**AreaService::getInstance()->getIdInFullNameList();** 都要执行redis查询就很慢

```php
public function appendText(cyModel $cy)
    {
        $areaList = AreaService::getInstance()->getIdInFullNameList();
        $cy->area_text = $areaList[$cy->area] ?? "";

        $cy->staff_number_history = json_decode($cy->staff_number_history, true);

        $cy_source_list = $this->getCySourceKeyValueList();
        $cy->cy_source_text = $cy_source_list[$cy->cy_source] ?? "";

        $cy_state_list = $this->getCyStateKeyValueList();
        $cy->cy_state_text = $cy_state_list[$cy->cy_state] ?? "";

        $cy_project_list = $this->getCyProjectKeyValueList();
        $cy->cy_project_text = $cy_project_list[$cy->cy_project] ?? "";
        return $cy;
    } 
```

这个问题的瓶颈点就在于 **`AreaService::getInstance()->getIdInFullNameList()` 每次循环都重新查询 redis**。
 解决思路就是：**把这个结果缓存到内存里（方法级 / 类级静态变量 / 外部提前获取）**，避免在循环中反复调用。

可以改造几种方式：

## 方法一：在循环外部提前获取

```php
$areaList = AreaService::getInstance()->getIdInFullNameList();

foreach ($cyList as $cy) {
    $this->appendText($cy, $areaList);
}
```

然后修改 `appendText`：

```php
public function appendText(cyModel $cy, array $areaList)
{
    $cy->area_text = $areaList[$cy->area] ?? "";

    $cy->staff_number_history = json_decode($cy->staff_number_history, true);

    $cy_source_list = $this->getCySourceKeyValueList();
    $cy->cy_source_text = $cy_source_list[$cy->cy_source] ?? "";

    $cy_state_list = $this->getCyStateKeyValueList();
    $cy->cy_state_text = $cy_state_list[$cy->cy_state] ?? "";

    $cy_project_list = $this->getCyProjectKeyValueList();
    $cy->cy_project_text = $cy_project_list[$cy->cy_project] ?? "";

    return $cy;
}
```

## 方法二：静态缓存（类内存缓存）

如果你不能改调用方式，可以在 `appendText` 内部用 **静态变量缓存**：

> 这样第一次调用时会去 Redis，后面都是内存里直接拿，循环中不会再触发 redis 查询。

```php
public function appendText(cyModel $cy)
{
    static $areaList = null;
    if ($areaList === null) {
        $areaList = AreaService::getInstance()->getIdInFullNameList();
    }

    $cy->area_text = $areaList[$cy->area] ?? "";
    $cy->staff_number_history = json_decode($cy->staff_number_history, true);

    static $cy_source_list = null;
    if ($cy_source_list === null) {
        $cy_source_list = $this->getCySourceKeyValueList();
    }
    $cy->cy_source_text = $cy_source_list[$cy->cy_source] ?? "";

    static $cy_state_list = null;
    if ($cy_state_list === null) {
        $cy_state_list = $this->getCyStateKeyValueList();
    }
    $cy->cy_state_text = $cy_state_list[$cy->cy_state] ?? "";

    static $cy_project_list = null;
    if ($cy_project_list === null) {
        $cy_project_list = $this->getCyProjectKeyValueList();
    }
    $cy->cy_project_text = $cy_project_list[$cy->cy_project] ?? "";

    return $cy;
}
```

## 方法三：依赖注入

更规范一点的做法，是在调用 service 的时候，就把 areaList、cy_source_list 等依赖传进去，这样 `appendText` 就是纯粹的数据加工函数。



## 静态变量在函数作用域内 初始化执行代码测试

在 PHP 里，**静态变量在函数作用域内只会初始化一次**，后续再调用这个函数时，值会一直保留在内存里，不会重新赋值。

比如下面这个例子：

```php
function test() {
    static $data = null;
    if ($data === null) {
        echo "执行查询...\n";
        $data = ['a' => 1, 'b' => 2]; // 模拟redis查询
    }
    return $data;
}

for ($i = 0; $i < 3; $i++) {
    $res = test();
    print_r($res);
}
```

输出结果：

```csharp
执行查询...
Array
(
    [a] => 1
    [b] => 2
)
Array
(
    [a] => 1
    [b] => 2
)
Array
(
    [a] => 1
    [b] => 2
)
```

可以看到：

- 第一次调用时 `$data === null`，于是执行了「查询」逻辑（比如 Redis）。
- 后面两次调用时 `$data !== null`，就直接返回已有的数据，不会再走 Redis。

------

所以放到你的代码里：

- **第一次调用 `appendText()`** → Redis 查询一次，赋值给静态变量。
- **后续循环调用 `appendText()`** → 直接用静态变量里的数据，不会再去 Redis。

这样就能保证循环里高效运行了。

## 性能解说

从 **性能角度** 来看，方法一和方法二在循环过程中基本 **没有差别**，原因是：

- **方法一**：在循环外先查一次 Redis，后续循环直接用传进来的数组。
- **方法二**：第一次调用函数时查一次 Redis，赋值给静态变量，后续循环直接用静态变量。

两者都只会触发 **一次 Redis 查询**，后续循环都是走内存。

------

### 细微差异：

1. **方法一**
   - 优点：逻辑清晰，谁依赖数据就明确传进去，函数是纯函数，方便测试。
   - 缺点：调用地方需要改代码（要先准备好 `$areaList`、`$cy_source_list` 等再传）。
2. **方法二**
   - 优点：调用方不用改，改造最小，旧代码直接生效。
   - 缺点：函数对外部依赖“隐藏”了，表面上看起来每次都查，但其实只查一次，不如方法一那么直观。
3. **执行速率**
   - 两者在 PHP 层面的性能差异几乎可以忽略（方法二每次多一次 `if ($var === null)` 判断，成本极低，纳秒级）。
   - 真正耗时的 Redis 查询，两种方法都是 **只执行一次**。

------

👉 总结：

- **性能：几乎一样**。
- **可维护性：方法一更清晰，方法二改造成本低**。

如果你的项目要长期维护、多人协作，推荐方法一；如果你现在就是要快速优化性能，不想动调用逻辑，直接上方法二。

#  简化逻辑判断

**简化前**

> 先看一下简化前的逻辑 
>
> if里面 又判断了if 读起来很麻烦

```php
            ###########################################################
            $is_transfer = false;
            //如果负责人离职&&未付清情况下(可以转交给其他人员)
            if (
                !empty($headModel)
                &&
                $headModel->staff_work_status == AssetMoreEnum::retuenValueFromType('4', 'work_status') //第一层 只判断离职
            ) {
                //没有签合同或者未付清 都属于 未付清
                if (empty($cySigned) || (!empty($cySigned) && $cySigned->is_full_money == CySigend::IS_FULL_MONEY__1)) { //第二层 判断未付清
                   $is_transfer = true;
                }
            }
            ###########################################################

            //如果合同不为空、收款金额大于0、&& (!离职未付清)
            if (!empty($cySigned) && $cySigned->total_received_money > 0 && $is_transfer == false) throw new PxsApiException('已签合同并收款不可再转交给其他负责人!');
```



**简化后**

> 使用更具描述性的变量名
>
> 将复杂的条件判断分解为独立的小判断
> 清晰地表达了业务逻辑关系
> 保留了原有的所有业务规则

```php
            // 简化版逻辑
            $canTransfer = false;
            // 检查负责人是否已离职
            $isHeadResigned = !empty($headModel) 
                && 
                $headModel->getOrigin('staff_work_status') == AssetMoreEnum::retuenValueFromType('4', 'work_status');
            // 检查是否未付清（没有合同或合同未付清）
            $isUnpaid = empty($cySigned) || (!empty($cySigned) && $cySigned->is_full_money == CySigend::IS_FULL_MONEY__1);
            // 如果负责人已离职且未付清，则允许转交
            if ($isHeadResigned && $isUnpaid) $canTransfer = true;//true允许转交

            // 如果已签合同并已收款，且不符合特殊转交条件，则禁止转交
            $has_total_received_money = !empty($cySigned) && $cySigned->total_received_money > 0;//已签合同并已收款
            if ($has_total_received_money && $canTransfer == false) { //有收款的 && 不符合特殊转交条件
                throw new PxsApiException('已签合同并收款不可再转交给其他负责人!');
            }
```

## 实际示例场景

> 这些优化方案的共同特点：
>
> 1. 将复杂条件拆分为独立的布尔变量，每个变量只负责一个判断
> 2. 使用清晰的变量名表达业务含义（如`$isHeadResigned`、`$isUnpaid`）
> 3. 减少嵌套层级，使逻辑流程更线性
> 4. 分离 "条件判断" 和 "业务操作"，使代码结构更清晰
> 5. 重要的业务规则可以提取为配置数组（如状态流转规则）
>
> 这种方式特别适合维护复杂的业务逻辑，当需求变更时，只需要修改对应的条件变量或规则配置即可。

###  用户权限校验逻辑优化

**优化前（嵌套复杂）：**

```php
if ($user) {
    if ($user->role == 'admin') {
        if ($user->status == 1) {
            // 管理员且状态正常，允许操作
            $allow = true;
        } else {
            $error = "管理员账号已禁用";
        }
    } else if ($user->role == 'editor') {
        if ($user->status == 1 && $user->hasPermission('edit')) {
            $allow = true;
        } else {
            $error = "编辑权限不足或账号异常";
        }
    } else {
        $error = "无权限访问";
    }
} else {
    $error = "用户未登录";
}
```

**优化后（拆分逻辑）：**

```php
// 基础状态判断
$isLoggedIn = !empty($user);
$isActive = $isLoggedIn && $user->status == 1;
$isAdmin = $isLoggedIn && $user->role == 'admin';
$isEditor = $isLoggedIn && $user->role == 'editor';
$editorHasPermission = $isEditor && $user->hasPermission('edit');

// 权限判定
if (!$isLoggedIn) {
    $error = "用户未登录";
} elseif ($isAdmin && $isActive) {
    $allow = true;
} elseif ($isEditor && $isActive && $editorHasPermission) {
    $allow = true;
} elseif (!$isActive) {
    $error = "账号已禁用";
} elseif ($isEditor && !$editorHasPermission) {
    $error = "编辑权限不足";
} else {
    $error = "无权限访问";
}
```

### 订单状态流转逻辑优化

**优化前（条件判断冗长）：**

```php
if ($order && $order->status != 'cancelled') {
    if ($action == 'pay' && $order->status == 'pending') {
        $order->status = 'paid';
        $order->paid_at = date('Y-m-d H:i:s');
    } elseif ($action == 'ship' && $order->status == 'paid') {
        $order->status = 'shipped';
        $order->shipped_at = date('Y-m-d H:i:s');
    } elseif ($action == 'receive' && $order->status == 'shipped') {
        $order->status = 'completed';
        $order->completed_at = date('Y-m-d H:i:s');
    } else {
        throw new Exception("当前订单状态不允许执行此操作");
    }
} else {
    throw new Exception("订单不存在或已取消");
}
```

**优化后（状态和动作分离）：**

```php
// 前置条件判断
$orderExists = !empty($order);
$orderNotCancelled = $orderExists && $order->status != 'cancelled';
$validStatusTransitions = [
    'pay' => ['from' => 'pending', 'to' => 'paid', 'field' => 'paid_at'],
    'ship' => ['from' => 'paid', 'to' => 'shipped', 'field' => 'shipped_at'],
    'receive' => ['from' => 'shipped', 'to' => 'completed', 'field' => 'completed_at'],
];

// 验证基础条件
if (!$orderExists) throw new Exception("订单不存在");
if (!$orderNotCancelled) throw new Exception("订单已取消");
if (!isset($validStatusTransitions[$action])) throw new Exception("不支持的操作");

// 验证状态流转合法性
$transition = $validStatusTransitions[$action];
if ($order->status != $transition['from']) {
    throw new Exception("当前订单状态不允许执行此操作");
}

// 执行状态更新
$order->status = $transition['to'];
$order->{$transition['field']} = date('Y-m-d H:i:s');
```

### 数据过滤条件优化

**优化前（查询条件嵌套）：**

```php
$query = DB::table('products');

if (!empty($category)) {
    $query->where('category_id', $category);
    if (!empty($minPrice)) {
        $query->where('price', '>=', $minPrice);
        if (!empty($maxPrice)) {
            $query->where('price', '<=', $maxPrice);
        }
    }
}

if (!empty($keyword)) {
    $query->where(function($q) use ($keyword) {
        $q->where('name', 'like', "%$keyword%")
          ->orWhere('description', 'like', "%$keyword%");
    });
}

$products = $query->get();
```

**优化后（条件分离）：**

```php
// 初始化查询
$query = DB::table('products');

// 提取条件变量
$hasCategory = !empty($category);
$hasPriceRange = $hasCategory && !empty($minPrice);
$hasMaxPrice = $hasPriceRange && !empty($maxPrice);
$hasKeyword = !empty($keyword);

// 应用分类条件
if ($hasCategory) {
    $query->where('category_id', $category);
    
    // 应用价格条件
    if ($hasPriceRange) {
        $query->where('price', '>=', $minPrice);
        if ($hasMaxPrice) {
            $query->where('price', '<=', $maxPrice);
        }
    }
}

// 应用关键词搜索
if ($hasKeyword) {
    $query->where(function($q) use ($keyword) {
        $q->where('name', 'like', "%$keyword%")
          ->orWhere('description', 'like', "%$keyword%");
    });
}

$products = $query->get();
```

### 一、**逻辑简化与清晰化**

1. **消除嵌套条件（减少 if-else 层级）**嵌套过深的条件判断会导致代码 "横向蔓延"，难以理解。**优化前**：

   ```php
   if ($user) {
       if ($user->isVip()) {
           if ($order->total >= 1000) {
               $discount = 0.8;
           } else {
               $discount = 0.9;
           }
       } else {
           $discount = 1.0;
       }
   } else {
       throw new Exception("未登录");
   }
   ```

   

   **优化后**（提前 return + 扁平化）：

   ```php
   if (!$user) throw new Exception("未登录");
   if (!$user->isVip()) return 1.0;
   return $order->total >= 1000 ? 0.8 : 0.9;
   ```

   

2. **用 "卫语句" 替代复杂条件**对于特殊情况，提前返回或抛出异常，避免主逻辑被嵌套。**优化前**：

   ```php
   function calculatePrice($goods, $user) {
       if ($goods && $user && $user->status == 1) {
           // 复杂的价格计算逻辑...
           return $price;
       } else {
           return 0;
       }
   }
   ```

   **优化后**：

   ```php
   function calculatePrice($goods, $user) {
       if (!$goods) return 0;       // 卫语句：商品不存在
       if (!$user) return 0;        // 卫语句：用户不存在
       if ($user->status != 1) return 0;  // 卫语句：用户状态异常
       
       // 主逻辑（无需嵌套）
       // 复杂的价格计算逻辑...
       return $price;
   }
   ```

   **补充:什么是卫语句**

   > 在 PHP 中，卫语句（Guard Clauses）是一种代码设计模式，用于提前检查条件并在不满足时退出函数或方法，从而避免深层嵌套的条件语句，使代码更清晰易读。
   >
   > 卫语句的核心思想是：**先处理异常情况，正常流程放在最后**。

​     基本示例

​    没有使用卫语句的代码（嵌套较深）：

```php
function calculatePrice($product, $user) {
    if ($product !== null) {
        if ($user !== null) {
            if ($user->hasPermission('purchase')) {
                // 正常业务逻辑
                return $product->price * $user->getDiscount();
            } else {
                throw new Exception("用户没有购买权限");
            }
        } else {
            throw new Exception("用户不存在");
        }
    } else {
        throw new Exception("产品不存在");
    }
}
```

使用卫语句重构后（更扁平清晰）：

```php
function calculatePrice($product, $user) {
    // 卫语句：提前处理异常情况
    if ($product === null) {
        throw new Exception("产品不存在");
    }
    
    if ($user === null) {
        throw new Exception("用户不存在");
    }
    
    if (!$user->hasPermission('purchase')) {
        throw new Exception("用户没有购买权限");
    }
    
    // 正常业务逻辑（放在最后，无需嵌套）
    return $product->price * $user->getDiscount();
}
```

卫语句的优势

1. 减少嵌套层级，提高代码可读性
2. 异常情况集中在函数开头，一目了然
3. 正常逻辑放在最后，突出主要业务流程
4. 便于后续扩展更多检查条件

常见用法场景

- 参数验证
- 权限检查
- 状态判断
- 前置条件验证

在实际开发中，合理使用卫语句可以显著提升代码质量，尤其适合处理有多个前置条件的函数或方法。

### 二、**变量与表达式优化**

1. **提取重复表达式为变量**重复出现的表达式会导致修改时需要多处同步，且降低可读性。**优化前**：

   ```php
   if ($order->create_time > strtotime('-30 days') && $order->status == 1 && $user->level >= 3) {
       // 逻辑1
   }
   if ($order->create_time > strtotime('-30 days') && $order->status == 1 && $user->points > 1000) {
       // 逻辑2
   }
   ```

   

   **优化后**：

   ```php
   $isRecentValidOrder = $order->create_time > strtotime('-30 days') && $order->status == 1;
   if ($isRecentValidOrder && $user->level >= 3) { /* 逻辑1 */ }
   if ($isRecentValidOrder && $user->points > 1000) { /* 逻辑2 */ }
   ```

   

2. **用常量 / 枚举替代魔法值**直接使用数字、字符串等 "魔法值" 会导致代码难以理解，修改时易出错。**优化前**：

   ```php
   if ($order->status == 2) {
       // 处理已发货订单
   }
   ```

   

   **优化后**：

   ```php
   // 定义枚举或常量
   class OrderStatus {
       const PENDING = 1;
       const SHIPPED = 2;
       const COMPLETED = 3;
   }
   
   if ($order->status == OrderStatus::SHIPPED) {
       // 处理已发货订单
   }
   ```

   

### 三、**函数与方法优化**

1. **拆分超大函数（单一职责原则）**一个函数只做一件事，避免几百行的 "万能函数"。**优化前**：

   ```php
   function handleOrder($order) {
       // 1. 验证订单合法性（50行）
       // 2. 计算价格（30行）
       // 3. 扣减库存（20行）
       // 4. 生成物流单（40行）
   }
   ```

   **优化后**：

   ```php
   function handleOrder($order) {
       $this->validateOrder($order);       // 验证
       $price = $this->calculatePrice($order);  // 计算价格
       $this->deductStock($order);         // 扣减库存
       $this->createLogistics($order);     // 生成物流单
   }
   ```

   

2. **减少函数参数（控制参数数量）**过多的参数会导致调用时容易传错顺序，可封装为对象或数组。**优化前**：

   ```php
   function createUser($name, $age, $email, $phone, $address, $role) {
       // ...
   }
   ```

   

   **优化后**：

   ```php
   class UserData {
       public $name;
       public $age;
       public $email;
       public $phone;
       public $address;
       public $role;
   }
   
   function createUser(UserData $data) {
       // 使用 $data->name 等
   }
   ```

   

### 四、**循环与迭代优化**

1. **减少循环内的计算**循环内的重复计算会浪费性能，尤其是大数据量时。**优化前**：

   ```php
   foreach ($products as $product) {
       if ($product->price > $maxPrice && $product->category == Category::ELECTRONICS) {
           // ...
       }
   }
   ```

   

   **优化后**：

   ```php
   $targetCategory = Category::ELECTRONICS;  // 循环外计算一次
   foreach ($products as $product) {
       if ($product->price > $maxPrice && $product->category == $targetCategory) {
           // ...
       }
   }
   ```

   

2. **提前终止循环**找到目标后立即 break，避免无效迭代。**优化前**：

   ```php
   $hasStock = false;
   foreach ($products as $product) {
       if ($product->id == $targetId && $product->stock > 0) {
           $hasStock = true;
       }
   }
   ```

   **优化后**：

   ```php
   $hasStock = false;
   foreach ($products as $product) {
       if ($product->id == $targetId) {
           $hasStock = $product->stock > 0;
           break;  // 找到目标后立即终止
       }
   }
   ```

   

### 五、**错误处理优化**

1. 用异常替代错误码

   

   错误码需要每层函数手动传递，异常可直接抛到上层处理。

   优化前:

   ```php
   function createOrder() {
       if (!$user) return -1;  // 错误码：用户不存在
       if (!$product) return -2; // 错误码：商品不存在
       // ...
   }
   
   // 调用时需要判断每个错误码
   $result = createOrder();
   if ($result == -1) { /* 处理用户不存在 */ }
   else if ($result == -2) { /* 处理商品不存在 */ }
   ```

   

   优化后

   ```php
   function createOrder() {
       if (!$user) throw new UserNotFoundException();
       if (!$product) throw new ProductNotFoundException();
       // ...
   }
   
   // 调用时集中处理异常
   try {
       createOrder();
   } catch (UserNotFoundException $e) {
       /* 处理用户不存在 */
   } catch (ProductNotFoundException $e) {
       /* 处理商品不存在 */
   }
   ```

   

### 六、**代码复用优化**

1. **提取重复逻辑为公共方法**多处出现的相同逻辑，应封装为公共函数或工具类。**优化前**：

   ```php
   // 页面A的价格格式化
   $priceA = number_format($rawPriceA, 2, '.', ',');
   // 页面B的价格格式化
   $priceB = number_format($rawPriceB, 2, '.', ',');
   ```

   

   **优化后**：

   ```php
   function formatPrice($price) {
       return number_format($price, 2, '.', ',');
   }
   
   $priceA = formatPrice($rawPriceA);
   $priceB = formatPrice($rawPriceB);
   ```

   

2. **使用设计模式简化复杂逻辑**例如用 "策略模式" 处理多变的算法，用 "工厂模式" 处理对象创建逻辑等。**示例（策略模式优化支付逻辑）**：

   ```php
   // 策略接口
   interface PaymentStrategy {
       function pay($amount);
   }
   
   // 具体实现（支付宝、微信）
   class AlipayStrategy implements PaymentStrategy {
       function pay($amount) { /* 支付宝支付逻辑 */ }
   }
   class WechatStrategy implements PaymentStrategy {
       function pay($amount) { /* 微信支付逻辑 */ }
   }
   
   // 使用时动态选择策略
   $payment = new PaymentContext(new AlipayStrategy());
   $payment->executePay(100);
   ```

#  开发项目命名

##  环境变量配置命名

1. **环境变量配置**在 `.env` 文件中添加 `APP_NAME` 配置：

   ```plaintext
   APP_NAME=你的项目名称
   ```

   这是最常用的方式，应用会优先读取此配置

2. **配置文件定义**打开 `config/app.php` 文件，找到 `name` 配置项：

   ```php
   'name' => env('APP_NAME', 'Laravel'),
   ```

   这里默认使用 `.env` 中的 `APP_NAME`，如果没有设置则使用 'Laravel' 作为默认值

3. **在代码中获取项目名称**定义后可以通过以下方式在代码中获取项目名称：

   ```php
   // 使用辅助函数
   $appName = config('app.name');
   
   // 或者通过应用实例
   $appName = app()->name;
   ```

4. **在视图中使用**在 Blade 模板中可以直接这样使用：

   ```blade
   {{ config('app.name') }}
   ```

建议使用 `.env` 文件的方式进行配置，这样可以在不同环境（开发、测试、生产）中轻松设置不同的项目名称，同时也符合 Laravel 的最佳实践。

##  文件夹修改项目命名

1. **修改项目文件夹名称**直接将本地的项目文件夹从 `laravel` 重命名为你想要的名称，例如 `housekeeping-service` 或 `家政服务`（中文名称也是可以的）

2. **修改项目内部配置**打开项目根目录下的 `.env` 文件，找到并修改：

   ```plaintext
   APP_NAME=家政服务
   ```

3. **（可选）修改配置文件默认值**打开 `config/app.php` 文件，修改默认值（当 `.env` 中没有设置时会使用此值）：

   ```php
   'name' => env('APP_NAME', '家政服务'),
   ```

4. **（可选）修改 Composer 配置**如果你需要修改项目的包名称（一般用于开源或团队内部包管理），可以编辑 `composer.json`：

   ```json
   {
       "name": "your-name/housekeeping-service",
       // 其他配置...
   }
   ```

   修改后运行 `composer dump-autoload` 使其生效

完成这些步骤后，项目在运行时就会显示你设置的 "家政服务" 名称了，比如在错误页面、日志输出等地方都会使用这个名称。

文件夹名称只是本地文件系统的标识，而 `APP_NAME` 才是应用程序内部使用的项目名称，两者可以保持一致也可以不同。




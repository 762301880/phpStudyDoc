##  tp5如何获取某张表的所有字段

**方法一：使用 getTableFields方法**

```php
use think\facade\Db;

// 获取表的所有字段
$fields = Db::table('your_table_name')->getTableFields();

// 打印字段信息
foreach ($fields as $field => $info) {
    echo "Field: $field, Type: {$info['type']}, Comment: {$info['comment']}<br>";
}

```

**方法二：使用原生 SQL 查询**
您也可以通过执行原生 SQL 查询来获取表的所有字段信息。以下是一个示例：

```php
use think\facade\Db;

// 获取表的所有字段
$result = Db::query("SHOW COLUMNS FROM your_table_name");

// 打印字段信息
foreach ($result as $row) {
    echo "Field: {$row['Field']}, Type: {$row['Type']}, Null: {$row['Null']}, Key: {$row['Key']}, Default: {$row['Default']}, Extra: {$row['Extra']}<br>";
}
```

**方法三：使用模型方法**
如果您已经定义了一个模型类，可以通过模型类来获取表的所有字段信息。以下是一个示例：

```php
namespace app\model;

use think\Model;

class YourModel extends Model
{
    protected $table = 'your_table_name';
}

// 获取表的所有字段
$model = new YourModel();
$fields = $model->getTableInfo('fields');

// 打印字段信息
foreach ($fields as $field => $info) {
    echo "Field: $field, Type: {$info['type']}, Comment: {$info['comment']}<br>";
}
```

##   获取所有的数据库表

```shell
$tables = Db::query('SHOW TABLES');
```

##  记录数据库字段变更情况

```php
        //$tableName = 'pxs_log_action';
        //$fields = Db::table("{$tableName}")->getTableFields();
        try {
            $originModel = LogAction::where('id', 1)->hidden(['request_body','update_time'])->find();
            $oldArr = $originModel->toArray();
            $originModel->ip = '127.0.0.3';
            $originModel->save();
            $newArr = $originModel->toArray();
            $diff = array_diff_assoc($oldArr, $newArr);
            // 检查 $diff 内容
            dd(json_encode($diff));
        } catch (Exception $exception) {
            dd([
                'message' => $exception->getMessage(),
                'line' => $exception->getLine(),
                'file' => $exception->getFile()
            ]);
        }
        
        # 结果展示
        "{"ip":"127.0.0.2"}"  
```

## 静态变量缓存数据

> 使用了`static`关键字定义了一个静态变量`$cy_source_list`，用于缓存数据
>
> 通过判断`$cy_source_list`是否为`null`，实现了延迟加载和缓存机制：
>
> - 第一次调用时，通过`$this->getCySourceKeyValueList()`获取数据并缓存
> - 后续调用直接使用缓存的数据，避免重复获取
>
> 这种模式通常被称为 "延迟初始化" 或 "惰性加载"(Lazy Loading)，同时结合了静态变量实现的简单缓存机制，
>
> 目的是提高性能，避免重复执行可能耗时的`getCySourceKeyValueList()`方法。

```php
public function appendText(cyModel $cy)
{
    static $cy_source_list = null;
    if ($cy_source_list === null) {
        $cy_source_list = $this->getCySourceKeyValueList();
    }
    $cy->cy_source_text = $cy_source_list[$cy->cy_source] ?? "";
}
```

